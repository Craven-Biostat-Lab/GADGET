Last updated 7/5/2011

Setting up the genetext database:

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

1) "gene_abstract" table:

Get the data linking genes to abstracts.  Go to ftp://ftp.ncbi.nih.gov/gene/DATA/
and download gene2pubmed.gz.

Create a database table:
CREATE TABLE  `genetext`.`gene_abstract_step1` (
  `tax` int(11) NOT NULL,
  `gene` int(11) NOT NULL,
  `abstract` int(11) NOT NULL,
  PRIMARY KEY (`gene`,`abstract`),
  KEY `tax` (`tax`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1

Uncompress gene2pubmed.gz, and load it into the table.

Link old discontinued gene ID's to new gene ID's.  Get gene_history from
ftp://ftp.ncbi.nih.gov/gene/DATA/ and load it into the following table:

CREATE TABLE  `genetext`.`gene_history` (
  `tax_id` int(11) NOT NULL,
  `entrez_id` int(11) NOT NULL,
  `old_id` int(11) NOT NULL,
  `old_sym` varchar(30) NOT NULL,
  `date` int(11) NOT NULL,
  PRIMARY KEY (`entrez_id`),
  KEY `old_id` (`old_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8

Add indices for 'entrez_id' and 'old_id'.

Create an updated gene_abstract table:

create table gene_abstract_step2
select 
	ga.tax tax,
	coalesce(gh.entrez_id, ga.gene) gene, 
	ga.abstract abstract
from gene_abstract_step1 ga
left join gene_history gh
on ga.gene = gh.entrez_id;

Add an index for the "gene" field.

Get homology data.  Go to ftp://ftp.ncbi.nih.gov/pub/HomoloGene/current/ and 
download the file called "homologene.data".

Create a database table:
CREATE TABLE .`homologene` (
  `group` int(11) NOT NULL,
  `tax` int(11) NOT NULL,
  `gene_entrez` int(11) NOT NULL,
  `gene_sym` varchar(30) NOT NULL,
  `prot_gi` int(11) NOT NULL,
  `prot_accession` varchar(30) NOT NULL,
  KEY `group` (`group`),
  KEY `tax` (`tax`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1

and load homologene.data into the table.  Add indeces for "group" and "tax."

Create a table linking genes to abstracts, using homology data, with the following commands:

create table gene_abstract_step3
select 
	h1.gene_entrez `gene_entrez_id`,
	ga.`abstract` `abstract_pmid`
from homologene h1
inner join homologene h2
on h1.`group` = h2.`group`
inner join gene_abstract_step2 ga
on h2.gene_entrez = ga.gene
where h1.tax = 9606
union distinct
select
	ga.gene `gene_entrez_id`,
	ga.`abstract` `abstract_pmid`
from gene_abstract_step2 ga
where ga.tax = 9606;

Add an index for gene_entrez_id.

You can drop the homologene, gene_history, gene_abstract_step1, and
gene_abstract_step2 tables to save space.

--------------------------------------------------------------------------------

2) "gene" table:

CREATE TABLE  `genetext`.`gene_raw` (
  `tax_id` smallint(5) unsigned DEFAULT NULL,
  `entrez_id` int(11) NOT NULL,
  `symbol` varchar(30) DEFAULT NULL,
  `locustag` varchar(100) DEFAULT NULL,
  `synonyms` varchar(250) DEFAULT NULL,
  `dbXrefs` varchar(250) DEFAULT NULL,
  `chromosome` varchar(7) DEFAULT NULL,
  `maplocation` varchar(100) DEFAULT NULL,
  `description` varchar(250) DEFAULT NULL,
  `type` varchar(20) DEFAULT NULL,
  `authsym` varchar(30) DEFAULT NULL,
  `authname` varchar(150) DEFAULT NULL,
  `nomstatus` char(1) DEFAULT NULL,
  `other` varchar(800) DEFAULT NULL,
  `date` int(11) DEFAULT NULL,
  PRIMARY KEY (`entrez_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8

create table gene
select
	ga.gene_entrez_id entrez_id,
	gr.symbol symbol,
	gr.description name,	
	gr.locustag locustag,
	gr.synonyms synonyms,
	gr.dbXrefs dbxrefs,
	gr.chromosome chromosome,
	gr.maplocation maplocation,
	gr.type `type`,
	gr.other other,
	count(ga.abstract_pmid) abstracts
from gene_raw gr
inner join gene_abstract_step3 ga # right join
on gr.entrez_id = ga.gene_entrez_id
group by ga.gene_entrez_id;

ALTER TABLE `genetext`.`gene` ADD COLUMN `id` INT  NOT NULL AUTO_INCREMENT FIRST,
 ADD PRIMARY KEY (`id`),
 ADD INDEX `entrez_id`(`entrez_id`);

-- create new gene_abstract table with links to new gene ID's
create table gene_abstract_step4
select g.id gene, ga.abstract_pmid
from gene_abstract_step3 ga
inner join gene g
on ga.gene_entrez = g.entrez_id;

ALTER TABLE `gene_abstract_step4` ADD COLUMN `id` INT  NOT NULL AUTO_INCREMENT FIRST,
 ADD PRIMARY KEY (`id`),
 ADD INDEX `abstract_pmid`(`abstract_pmid`),
 ADD INDEX `abstract_gene`(`abstract_pmid`,`gene`);

-- take out abstracts referencing more than 1000 genes
create table gene_abstract
select ga.*
from gene_abstract_step4 ga
inner join (
	select abstract_pmid from gene_abstract_step4
	group by abstract_pmid having count(distinct gene) <= 1000
) a
on ga.abstract_pmid = a.abstract_pmid;

ALTER TABLE `genetext`.`gene_abstract` MODIFY COLUMN `id` INTEGER  NOT NULL AUTO_INCREMENT,
 ADD PRIMARY KEY (`id`),
 ADD INDEX `gene`(`gene`),
 ADD INDEX `abstract_pmid`(`abstract_pmid`);
 
-- Split database crosslinks:
ALTER TABLE `genetext`.`gene` ADD COLUMN `dbxrefs_split` BOOLEAN  NOT NULL DEFAULT 0 AFTER `dbxrefs`,
 ADD COLUMN `hgnc_id` INT  AFTER `dbxlinks_split`,
 ADD COLUMN `mim_id` INT  AFTER `hgnc_id`,
 ADD COLUMN `ensembl_id` INT  AFTER `mim_id`,
 ADD COLUMN `hprd_id` INT  AFTER `ensembl_id`;
-- run "splitlinks.py" 


-------------------------------------------------------------------------------------
-- Events

-- find all events tied to abstracts in our `abstract` table
-- if you want all events, skip this table and use the "homologene_event"  table
-- instead of this one for the "root_event" and "event_all" tables.
create table event_with_abstract
select e.`id`, e.`type`
from homologene_event e

inner join homologene_event_occmap m
on e.id = m.homologene_event_id
inner join occurrence_event o
on m.occurrence_event_id = o.id
inner join abstract ab
on ab.pubmed_id = o.pmid

group by e.id;

ALTER TABLE `event_with_abstract` ADD PRIMARY KEY (`id`);

-- find all of the top-level events in the set (roots of complex events)
create table root_event
select e.`id`, e.`type`
from event_with_abstract e
left join homologene_eventargument_event a
on e.id = a.arg_homologene_event_id
where a.arg_homologene_event_id is null;

ALTER TABLE `root_event` ADD PRIMARY KEY (`id`);

-- create a table of all events
create table event_all
select 
	e.`id`, 
	e.`type`, 
	r.`id` `root`,
	if(r.`id` is null, 0, 1) `is_root`
from event_with_abstract e
left join root_event r
using (id);

ALTER TABLE `event_all` ADD PRIMARY KEY (`id`),
 ADD INDEX `root`(`root`);

-- find the root events for each event.  Run this a couple times until "root" 
-- is not null for any row (select count(*) from event_all where root is null;)
update event_all e
inner join homologene_eventargument_event a
on e.id = a.arg_homologene_event_id
inner join event_all r
on a.homologene_event_id = r.id
set e.root := r.root;

-- tie genes to events
create table event_gene_all
select
	g.id gene,
	ea.homologene_event_id event,
	e.root root,
	ea.role role
from homologene_eventargument_ggp ea
inner join event_all e
on ea.homologene_event_id = e.id
inner join homologene_gene h
using (homologene_id)
inner join gene g
on h.entrezgene_id = g.entrez_id

ALTER TABLE `turku`.`event_gene_all` ADD COLUMN `id` INT  NOT NULL AUTO_INCREMENT FIRST,
 ADD PRIMARY KEY (`id`);

-- Get complex events with more than one gene (homologene group)
create table event
select e.* from event_all e
inner join event_gene_all eg
on e.root = eg.root
group by e.id
having count(distinct eg.homologene_id) > 1;

ALTER TABLE `event` ADD PRIMARY KEY (`id`),
 ADD INDEX `root`(`root`);

-- get corresponding event_genes for new events table
create table event_gene
select eg.* from event_gene_all eg
inner join event e
on eg.root = e.root
group by eg.id;

ALTER TABLE `turku`.`event_gene` MODIFY COLUMN `id` INT  NOT NULL AUTO_INCREMENT,
 ADD PRIMARY KEY (`id`),
 ADD INDEX `gene`(`gene`),
 ADD INDEX `event`(`event`);

-- link events to abstracts
create table event_abstract
select 
	o.id id,
	e.id event,
	o.pmid abstract_pmid,
	o.confidence_min
from event e
inner join homologene_event_occmap m
on e.id = m.homologene_event_id
inner join occurrence_event o
on m.occurrence_event_id = o.id;

ALTER TABLE `turku`.`event_abstract` MODIFY COLUMN `id` INT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
 ADD PRIMARY KEY (`id`),
 ADD INDEX `event`(`event`),
 ADD INDEX `abstract_pmid`(`abstract_pmid`);

-- table describing complex event structures
create table event_event
select 
	ee.homologene_event_id parent,
	ee.arg_homologene_event_id child,
	ee.role
from homologene_eventargument_event ee
inner join event e
on e.id = ee.homologene_event_id;

ALTER TABLE `event_event` ADD PRIMARY KEY (`parent`, `child`, `role`);














--------------------------------------------------------------------
----- ATTEMPT #2

-- Create a parent-child table describing the event hierarchy (for only events
-- extracted from abstracts in our `abstract` table.  To include all abstracts,
-- take out the inner join to the `abstract` table (last 2 lines.))
create table parent_child_all
select distinct
	ea.homologene_event_id parent,
	ea.arg_homologene_event_id child,
	ea.role role,
	o.pmid abstract
from homologene_eventargument_event ea
inner join homologene_event_occmap m
on ea.homologene_event_id = m.homologene_event_id
inner join occurrence_event o
on m.occurrence_event_id = o.id
inner join abstract a
on a.pubmed_id = o.pmid;

-- Add indices to `parent_child_all`
ALTER TABLE `turku`.`parent_child_all` ADD COLUMN `root` INT  DEFAULT NULL AFTER `abstract`,
 ADD PRIMARY KEY (`parent`, `child`, `role`, `abstract`),
 ADD INDEX `parent_abstract`(`parent`, `abstract`),
 ADD INDEX `child_abstract`(`child`, `abstract`);

-- Find root-events for complex events (run this once)
update parent_child_all c
left join parent_child_all p
on p.child = c.parent
and p.abstract = c.abstract
set c.root := c.parent
where p.child is null;

-- Propogate the root events down each hierarchy.  Run this a couple times until
-- there are not any rows with root=null.  Until
-- (select count(*) from parent_child_all where root is null;) returns 0.
update parent_child_all c
inner join parent_child_all p
on p.child = c.parent
and p.abstract = c.abstract
set c.root := p.root;
